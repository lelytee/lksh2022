# LCA + LA

## LCA

Пусть есть дерево из $n$ Макнилов. Ирина Цыс вам задает $m$ запросов: найдите *Наименьший Общий Предок* у двух Макнилов

Более формально: вам дано дерево из $n$ вершин. Вам подаются запросы формата $v$, $u$. Требуется найти их *Наименьший Общий Предок*

**Наименьший Общий Предок** (LCA) вершины $v$ и $u$ - такая вершина, которая является предком вершины $v$ и $u$, а также находится на самой большой глубине

Давайте рассмотрим три типа решения:
    1) за $O(n)$ на запрос (тупняк)
    2) за $O(logN)$ на запрос (двоичные подъемы)
    3) за $O(1)$ на запрос + препроцессинг за $O(nlogn)$


## Stupid за $O(n)$ на запрос

Будем постепенно подниматься от двух вершин одновременно двумя указателями, пока один из указателей не прейдет уже в посещенную вершину.
Это и будет LCA этих двух вершин.


## Smart $O(logN)$ на запрос

Воспользуемся обходом DFS для предпосчета массивов t_in и t_out

t_in[v] - в какой момент мы вошли в вершину

t_out[v] - в какой момент мы вышли из выршины

pr[v][i] - подъем от вершины v на 2^i

С помощью Двоичных подъемов мы можем за $O(logN)$ отвечать на запрос
//TODO: рассказать подробнее, мне просто лень + руки замерзли

```cpp
int timer = 0;

ll check_parent(ll a, ll b) { // проверка на то, что вершина a является предком вершины b
    return (t_in[a] <= t_in[b]) && (t_out[a] >= t_out[b]);
}

void dfs(ll v, ll p = 0, ll lena = 0) { // предпосчет pr[v][i] и t_in[v] и t_out[v]
    t_in[v] = timer++;
    pr[v][0] = p;
    for (ll i = 1; i <= l; i++){
        pr[v][i] = pr[pr[v][i - 1]][i - 1];
    }
    for (auto u : g[v]) {
        if (u != p) {
            dfs(u, v, lena + 1);
        }
    }
    t_out[v] = timer++;
}

ll LCA_function(ll a, ll b) {
    if (check_parent(a, b)){
        return a;
    }
    if (check_parent(b, a)){
        return b;
    }
    for (ll i = l; i >= 0; i--){
        if (!check_parent(pr[a][i], b)) { // Двоичные подъемы
            a = pr[a][i];
        }
    }
    return pr[a][0];
}
```

## GENIUS за $O(1)$ на запрос + препроцессинг за $O(nlogn)$

Давайте попробуем свести задачу LCA к задаче про RMQ

