# LCA


## Это база.

Пусть есть дерево из $n$ Макнилов. Ирина Цыс вам задает $m$ запросов: найдите *Наименьший Общий Предок* у двух Макнилов

Более формально: вам дано дерево из $n$ вершин. Вам подаются запросы формата $v$, $u$. Требуется найти их *Наименьший Общий Предок*

**Наименьший Общий Предок** (LCA) вершины $v$ и $u$ - такая вершина, которая является предком вершины $v$ и $u$, а также находится на самой большой глубине

Давайте рассмотрим три типа решения:
    1) за $O(n)$ на запрос (тупняк)
    2) за $O(logn)$ на запрос (двоичные подъемы)
    3) за $O(1)$ на запрос + препроцессинг за $O(nlogn)$


## Stupid за $O(n)$ на запрос

Будем постепенно подниматься от двух вершин одновременно двумя указателями, пока один из указателей не прейдет уже в посещенную вершину.
Это и будет LCA этих двух вершин.


## Smart за $O(logN)$ на запрос

Воспользуемся обходом DFS для предпосчета массивов t_in и t_out

t_in[v] - в какой момент мы вошли в вершину

t_out[v] - в какой момент мы вышли из выршины

pr[v][i] - подъем от вершины v на 2^i

С помощью Двоичных подъемов мы можем за $O(logn)$ отвечать на запрос
//TODO: рассказать подробнее, мне просто лень + руки замерзли

```cpp
int timer = 0;

ll check_parent(ll a, ll b) { // проверка на то, что вершина a является предком вершины b
    return (t_in[a] <= t_in[b]) && (t_out[a] >= t_out[b]);
}

void dfs(ll v, ll p = 0, ll lena = 0) { // предпосчет pr[v][i] и t_in[v] и t_out[v]
    t_in[v] = timer++;
    pr[v][0] = p;
    for (ll i = 1; i <= l; i++){
        pr[v][i] = pr[pr[v][i - 1]][i - 1];
    }
    for (auto u : g[v]) {
        if (u != p) {
            dfs(u, v, lena + 1);
        }
    }
    t_out[v] = timer++;
}

ll LCA_function(ll a, ll b) {
    if (check_parent(a, b)){
        return a;
    }
    if (check_parent(b, a)){
        return b;
    }
    for (ll i = l; i >= 0; i--){
        if (!check_parent(pr[a][i], b)) { // Двоичные подъемы
            a = pr[a][i];
        }
    }
    return pr[a][0];
}
```

## GENIUS за $O(1)$ на запрос + препроцессинг за $O(nlogn)$

Давайте попробуем свести задачу LCA к задаче про RMQ

Заметим, что у двух вершин в дереве ровно один путь + LCA($v$, $u$) лежит на этом путе

Но если еще подумать, то вершина LCA($v$, $u$) на этом путе - особенная. Она самая *низкая* из всех вершин на пути (минимальное расстояние до корня) 
Поэтому мы можем обойти сначала граф, запомнить вхождения и выходы, а после с помощью RMQ находить минимум на отрезке
Как мы знаем, Sparse Table работают за $O(1)$ на запрос + предпосчет за $O(nlogn)$.


Псевдокод
```cpp
const int MAX = 100100;
vector<vector<int>> g(MAX), sparse;
vector<int> go, h, logs, used(MAX);

void build() {
    logs.resize(sz(h), 0);
    for (int i = 1; i < sz(h); i++) {
        logs[i] = logs[(i - 1) / 2] + 1;
    }
    sparse.resize(logs.back() + 1, vector<int>(sz(h), -1));
    for (int i = 0; i < sz(h); i++) {
        sparse[0][i] = i;
    }
    for (int k = 1; (1 << k) <= sz(h); k++) {
        for (int i = 0; i < sz(h); i++) {
            if (i + (1 << k) - 1 >= sz(h)) {
                break;
            }
            if (h[sparse[k - 1][i]] > h[sparse[k - 1][i + (1 << (k - 1))]]) {
                sparse[k][i] = sparse[k - 1][i + (1 << (k - 1))];
                continue;
            }
            sparse[k][i] = sparse[k - 1][i];
        }
    }
    for (int i = 1; i <= logs.back(); i++) {
        for (int j = 0; j < sz(h); j++) {
            if (sparse[i][j] == -1) {
                sparse[i][j] = sparse[i - 1][j];
            }
        }
    }
}

int get_min(int l, int r) {
    if (h[sparse[logs[r - l]][l]] > h[sparse[logs[r - l]][r - (1 << logs[r - l]) + 1]]) {
        return sparse[logs[r - l]][r - (1 << logs[r - l]) + 1];
    }
    return sparse[logs[r - l]][l];
}

void dfs(int v, int d) {
    used[v] = true;
    go.pb(v);
    h.pb(d);
    for (auto &u : g[v]) {
        if (!used[u]) {
            dfs(u, d + 1);
            go.pb(v);
            h.pb(d);
        }
    }
}

int main() {
    // ввод графа, n - кол-во вершин
    dfs(0, 0);
    vector<int> first(n + 1, -1);
    for (int i = 0; i < sz(go); i++) {
        if (first[go[i]] == -1) {
            first[go[i]] = i;
        }
    }
    build();
    // m - кол-во запросов
    for (int i = 0; i < m; i++) {
        // v, u - вершины
        ans = go[get_min(min(first[v], first[u]), max(first[v], first[u]))];
    }
}
```


# Задачи на LCA

## Свидание

Александр Макнил пригласил на свидание Ирину Цыс!!! Конечно же, она не могла отказаться!
Вот настал долгожданный момент... Но Макнил очень сильно напутал с местом встречи. 
В итоге оба из них пришли в ТЦ Барнаул, в котором $n$ магазинов. Так получилось, что ТЦ в форме дерева. 
Известно, что Саша и Ира в магазинах с номерами $v$ и $u$ соответственно.
Наши голубки очень ленивы, поэтому они хотят пройти через минимальное количество магазинов. 
Помогите им найти новое место встречи!

## 